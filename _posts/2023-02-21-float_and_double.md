---
layout: post
title: "浮点型及其存储方式"
date:   2022-02-21
tags: [Data Structure]
comments: true
author: nullptr
---

## **浮点型及其存储方式**
有些时候需要变量能存储带小数点的数，或者能存储极大数或极小数。这类数可以用浮点(因小数点是“浮动的”而得名)格式进行存储。C语言提供了3种浮点型别，对应三种不同的浮点格式。

当精度要求不严格时(小数点后少于六位)，**float**型别是很适合的型别。**double**提供更高的精度， 对绝大多数程序来说够用了。**long double**支持极高精度的要求，很少会用到。

C标准没有说明float、double和long double型别提供的精度到底是多少，因为不同计算机可以用不同方法存储浮点数。大多数现代计算机遵循IEEE754标准(即IEC 60559) 的规范，所以这里也将它作为一个示例。



### 一、IEEE浮点标准
由IEEE开发的IEEE标准提供了两种主要的浮点数格式：**单精度(32位)** 和**双精度(64位)**。数值以科学记数法的形式存储，每一个数都由三部分组成：**符号、指数和小数**。指数部分的位数说明了数值的可能大小程度，而小数部分的位数说明了精度。单精度格式中，指数长度为8位，而小数部分占了23位。因此，单精度数可以表示的最大值大约是3.40×1038，其中精度是6个十进制数字。

IEEE标准还描述了另外两种格式：**单扩展精度**和**双扩展精度**。标准没有指明这些格式中的位数，但要求单扩展精度型别至少为43位，而双扩展精度型别至少为79位。

| **型别** | **最小值**       | **最大值**      | **精度**     | **备注**   |
| :------- | :--------------- | :-------------- | :----------- | :--------- |
| float    | 1\.175 49×10-38  | 3\.402 82×1038  | 小数点后6位  | 单精度32位 |
| double   | 2\.225 07×10-308 | 1\.797 69×10308 | 小数点后15位 | 双精度64位 |

上表给出了根据IEEE标准实现的浮点型别特征。[表中给出了规范化的最小正值， 非规范化的数可以更小。] long double型别没有显示在此表中， 因为它的长度随着机器的不同而变化，而最常见的大小是80位和128位。


### 二、存储方式
对于浮点型数据，首先我们需要明白的一点是：浮点数和整型数的编码方式是不一样的，IEEE浮点标准采用如下形式来标识一个浮点数。

V = (-1)<sup>S</sup>⋅M⋅2<sup>E</sup>

- (-1)<sup>S</sup> 表示符号位，当S=0时，表示正数，当S=1时，表示负数。
- M 表示有效数字，是一个二进制小数，其值大于等于1，小于2。
- 2<sup>E</sup> 表示指数位。


下面，我将用float作为例子，double道理也是一样的，只是位数有所不同。

**例如**：十进制数：**88.8125** ⇒ 二进制数：101 1000.1101
然后将101 1000.1101化成上述公式M的形式，其范围是[1,2)，所以将小数点左移6位，得到1.0110001101×26（这里不懂的话对比十进制，小数点左移一位乘以10，二进制则乘以2）。

最后得到S = 0、M = 1.0110001101、E = 6，但是事情并没有那么简单，我们接着往下看。



## IEEE 754对有效数字M和指数E的规定。
###### **1、有效数字M：**
1⩽M<2，也就是说，M写成1.xxx……的形式，其中xxx……表示小数部分。

IEEE 754规定，在计算机内部保存M时，默认这个数的第一位总是1，因此可以被舍去，只保存小数部分。比如保存1.0110001101时，只保存0110001101，后面的位数补0就可以了，等到读取的时候，再把第一位的1补上去。
###### **2、指数E:**
首先，E为一个无符号整数（unsigned int）

如果E为8位，它的取值范围为0 ~ 255；如果E为11位，它的取值范围为0~2047。但是，我们知道，科学计数法是可以出现负数的，所以IEEE 754规定，存入内存的E是真实值加上一个中间数，对于8位的E，中间数是127，对于11位的E，中间数是1023。比如，26 的E是6，所以保存为32位浮点数时，必须保存为6+127=133，即10000101。

### 重点：
<u>**结合上述补充的信息完善例子**</u>

float:

十进制数：88.8125 二进制为：101 1000.1101 == 1.0110001101×26

- 符号位：0
- 指数位：6+127=133 二进制为：1000 0101
- 小数位：1.0110001101去掉最高位1则为：0110001101

因此浮点数88.8125的IEEE浮点表示为：

| 0      | 1000 0101 | 011 0001 1010 0000 0000 0000 |
| :----: | :-------: | :--------------------------: |
| 符号位 | 指数域    | 小数域                       |

###### 根据指数域不同取值分为一下三种情况：
###### 1）**E不全为0或不全为1（规格化值）**
这是最常见情况，取出内存中的数时，指数E的计算值减去127（或1023），得到真实值，再将有效数字M前加上第一位的1。
###### 2）**E全为0（非规格化值）**
这时，浮点数的指数E等于1-127（或1-1023）即为真实值，有效数字M不再加上第一位的1，而是还原为0.xxxxxxx的小数。这样做是为了表示正负零，以及接近于0的很小的数字。

举个例子：编码为如下情形：

0 0000 0000 000 0000 0000 0000 0000 0001
即2(-23)×2(-126)=2(-149)，转成10进制大约等于1.4×10(-45)，这就是单精度所能表达最小的正数了。
###### 3）**E全为1（特殊数值）**
当指数域全为1时属于这种情形。此时，如果小数域全为0且符号域S=0，则表示正无穷，如果小数域全为0且符号域S=1，则表示负无穷。如果小数域不全为0时，浮点数将被解释为NaN， 即不是一个数(Not a Number) 。比如计算负数平方根或处理未初始化数据时。